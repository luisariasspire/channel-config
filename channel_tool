#! /usr/bin/env python3

import argparse
from copy import deepcopy
from collections.abc import Sequence
import difflib
import itertools
import jsonschema
from ruamel.yaml import YAML
import os
import requests
import sys
from tabulate import tabulate
from io import StringIO

ENVS = ["staging", "production"]
TK_DOMAINS = {"staging": "sbox", "production": "cloud"}
SCHEMA_FILE = "schema.yaml"
SAT_DIR = "sat"
GS_DIR = "gs"
GROUND_STATION = "groundstation"
SATELLITE = "satellite"

with open("contact_type_defs.yaml") as f:
    yaml = YAML()
    CONTACT_TYPE_DEFS = yaml.load(f)


class AlreadyExistsError(Exception):
    pass


class NoConfigurationError(Exception):
    pass


class ValidationError(Exception):
    pass


class MissingTemplateError(Exception):
    pass


def schema_fields():
    """Extract a set of possible field names in the channel JSON schema."""

    def discover_keys(s):
        """Extract the transitive closure of map keys from a nested dictionary."""
        keys = set()
        try:
            for k, v in s.items():
                keys.add(k)
                keys = keys.union(discover_keys(v))
        except AttributeError:
            if isinstance(s, Sequence) and not isinstance(s, str):
                for v in s:
                    keys = keys.union(discover_keys(v))
        return keys

    schema = load_schema()
    return discover_keys(schema)


def modify(cdef, args):
    """Apply modifications to a channel from argparse arguments."""
    new_cdef = deepcopy(cdef)
    vargs = vars(args)
    fields = schema_fields()
    for field in fields:
        if field in vargs and vargs[field] is not None:
            new_cdef[field] = vargs[field]
    if args.comment:
        new_cdef.yaml_set_start_comment(args.comment)
    return new_cdef


def add_config(args):
    def do_add(asset, channel, existing):
        if not existing:
            template = find_template(channel)
            return modify(template, args)
        else:
            msg = (
                f"Configuration for {channel} already exists on {asset}.\n"
                f"(Tip: Use `channel_tool edit {asset} {channel}` to edit the configuration.)"
            )
            if not args.fail_fast:
                print(msg)
                return existing
            else:
                raise AlreadyExistsError(msg)

    apply_update(args.environment, args.assets, args.channels, do_add, yes=args.yes)


def edit_config(args):
    def do_edit(asset, channel, existing):
        if existing:
            return modify(existing, args)
        else:
            msg = (
                f"No configuration for {channel} on {asset}.\n"
                f"(Tip: Use `channel_tool add {asset} {channel}` to add one from a template.)"
            )
            if not args.fail_fast:
                print(msg)
            else:
                raise NoConfigurationError(msg)

    apply_update(args.environment, args.assets, args.channels, do_edit, yes=args.yes)


def tk_url(env):
    env_domain = TK_DOMAINS[env]
    return f"https://theknowledge.{env_domain}.spire.com/v2/"


def load_tk_asset(env, kind, name=None):
    if name:
        suffix = f"/{name}"
    else:
        suffix = ""
    r = requests.get(tk_url(env) + kind + suffix)
    r.raise_for_status()
    return r.json()


def compare_channels(sat_config, gs_config, satellite, ground_station):
    """Compare the configured channels for the given satellite and ground station."""
    shared = []
    mismatched = []

    def channel_rejection_reason(sat_chan, gs_chan):
        """Apply channel matching rules and return the reason for mismatch, if any."""
        if not sat_chan["legal"]:
            return "Channel marked illegal on satellite"

        if not gs_chan["legal"]:
            return "Channel marked illegal on ground station"

        if not sat_chan["enabled"]:
            return "Channel disabled on satellite"

        if not gs_chan["enabled"]:
            return "Channel disabled on ground station"

        sat_dir = sat_chan["directionality"]
        gs_dir = gs_chan["directionality"]
        if sat_dir != gs_dir:
            return f"Directionality mismatch ({sat_dir} vs {gs_dir})"

        sat_countries = sat_chan["allowed_license_countries"]
        gs_countries = gs_chan["allowed_license_countries"]

        def normalize(country):
            return country[:2]

        sat_country = normalize(satellite["license_country"])
        gs_country = ground_station["license_country"]

        if sat_country not in gs_countries:
            return f"Satellite license country {sat_country} not in set {gs_countries}"

        if gs_country not in sat_countries:
            return f"Ground station license country {gs_country} not in set {sat_countries}"

        return None

    channels = set(sat_config.keys()).union(set(gs_config.keys()))
    for chan in channels:
        sat_chan = sat_config.get(chan)
        gs_chan = gs_config.get(chan)
        if sat_chan and gs_chan:
            reason = channel_rejection_reason(sat_chan, gs_chan)
            if reason:
                mismatched.append((chan, reason))
            else:
                shared.append(chan)
        elif sat_chan:
            mismatched.append((chan, "Channel not configured on ground station"))
        else:
            mismatched.append((chan, "Channel not configured on satellite"))
    shared = sorted(shared)
    mismatched = sorted(mismatched)
    return (shared, mismatched)


def audit_config(env, sat, gs):
    """Compute and display a report of the channel (mis)matches between assets."""
    sat_config = load_asset_config(env, sat)
    gs_config = load_asset_config(env, gs)
    satellite = load_tk_asset(env, SATELLITE, sat)
    ground_station = load_tk_asset(env, GROUND_STATION, gs)

    shared, mismatched = compare_channels(
        sat_config, gs_config, satellite, ground_station
    )

    header = f"Audit summary for {sat} -> {gs}"
    print(header)
    print("=" * len(header), end="\n\n")

    print("Valid Channels")
    if shared:
        print(tabulate([[s] for s in shared]))
    else:
        print("(No channels passed licensing rules)")
    print()

    print("Rejected Channels")
    print(tabulate(mismatched))
    print()


def audit_configs(args):
    for sat, gs in itertools.product(args.satellites, args.ground_stations):
        audit_config(args.environment, sat, gs)


def validate_all(args):
    for asset_type in [GROUND_STATION, SATELLITE]:
        print(f"Validating {asset_type} templates...")
        validate_file(
            "templates.yaml",
            inspect_keys=True,
            preprocess=lambda x: filter_properties(asset_type, x),
        )
        print("PASS")

    for env in ENVS:
        print(f"Validating {env} satellites...")
        sat_dir = os.path.join(env, SAT_DIR)
        all_sats = os.listdir(sat_dir)
        for sf in all_sats:
            print(f"{sf}... ", end="")
            validate_file(os.path.join(sat_dir, sf))
            print("PASS")

        print(f"Validating {env} ground stations...")
        gs_dir = os.path.join(env, GS_DIR)
        all_stations = os.listdir(gs_dir)
        for gsf in all_stations:
            print(f"{gsf}... ", end="")
            validate_file(os.path.join(gs_dir, gsf))
            print("PASS")

    print("All passed!")


def validate_file(cf, inspect_keys=True, preprocess=None):
    with open(cf) as f:
        yaml = YAML()
        config = yaml.load(f)
        if inspect_keys:
            for key in config:
                try:
                    c = config[key]
                    if preprocess:
                        c = preprocess(c)
                    validate_one(c)
                except Exception as e:
                    raise ValidationError(f"Failed to validate {cf}#{key}: {e}")
        else:
            try:
                c = config
                if preprocess:
                    c = preprocess(c)
                validate_one(config)
            except Exception as e:
                raise ValidationError(f"Failed to validate {cf}: {e}")


def validate_one(config):
    schema = load_schema()
    jsonschema.validate(config, schema)


# Memoize the JSON Schema definition.
loaded_schema = None


def load_schema():
    global loaded_schema
    if not loaded_schema:
        yaml = YAML()
        with open(SCHEMA_FILE) as f:
            # File has "schema" and "definitions" as top-level fields.
            loaded_schema = yaml.load(f)["schema"]
    return loaded_schema


def find_template(channel):
    template_file = "templates.yaml"
    if os.path.exists(template_file):
        with open(template_file) as f:
            yaml = YAML()
            templates = yaml.load(f)
            if channel in templates:
                return templates[channel]
            else:
                raise MissingTemplateError(f"Could not find template for {channel}")
    else:
        raise FileNotFoundError(f"Could not find file {template_file}")


def locate_assets(env, assets):
    def name(p):
        return os.path.splitext(os.path.basename(p))[0]

    if assets == "all_gs":
        return [name(p) for p in os.listdir(os.path.join(env, GS_DIR))]
    elif assets == "all_sat":
        return [name(p) for p in os.listdir(os.path.join(env, SAT_DIR))]
    elif assets == "all":
        vs = locate_assets(env, "all_gs")
        vs.extend(locate_assets(env, "all_sat"))
        return vs
    else:
        return assets.split(",")


def filter_properties(asset_type, chan):
    """Filter the channel configuration properties based on the asset type."""
    if chan:
        if asset_type != GROUND_STATION and "ground_station_constraints" in chan:
            del chan["ground_station_constraints"]
        if asset_type != SATELLITE and "satellite_constraints" in chan:
            del chan["satellite_constraints"]
    return chan


def apply_update(env, assets, channels, tfm, yes=False):
    for asset in locate_assets(env, assets):
        asset_config = load_asset_config(env, asset)
        for channel in channels:
            existing_chan = asset_config.get(channel)
            try:
                updated_chan = tfm(asset, channel, existing_chan)
                if updated_chan:
                    asset_type = infer_asset_type(asset)
                    updated_chan = filter_properties(asset_type, updated_chan)
                    validate_one(updated_chan)
                if updated_chan != existing_chan:
                    if yes or confirm_changes(
                        asset, channel, existing_chan, updated_chan
                    ):
                        asset_config[channel] = updated_chan
                        print(f"Updated {channel} definition for {asset}.")
                else:
                    print(f"No changes for {channel} on {asset}.")
            except AlreadyExistsError as e:
                print(f"Error: {e}")
        write_asset_config(env, asset, asset_config)


def confirm_changes(asset, channel, existing, new):
    print(f"Changing asset configuration for {channel} on {asset}. Diff:")
    print(
        "".join(
            difflib.unified_diff(
                dumps(existing).splitlines(keepends=True),
                dumps(new).splitlines(keepends=True),
            )
        )
    )
    response = input("Update asset configuration? [y/N] ")
    if response in ["y", "Y"]:
        return True
    else:
        print("Canceled.")
        return False


def dumps(obj):
    with StringIO() as stream:
        yaml = YAML()
        yaml.dump(obj, stream)
        return stream.getvalue()


def load_asset_config(env, asset):
    config_file = infer_config_file(env, asset)
    if not os.path.exists(config_file):
        return {}
    with open(config_file, mode="r") as f:
        yaml = YAML()
        config = yaml.load(f)
        if config:
            return config
        else:
            return {}


def write_asset_config(env, asset, asset_config):
    config_file = infer_config_file(env, asset)
    if asset_config:
        with open(config_file, mode="w+") as f:
            yaml = YAML()
            yaml.dump(asset_config, f)
    elif os.path.exists(config_file):
        os.remove(config_file)


def infer_asset_type(asset):
    if asset.endswith("gs"):
        return GROUND_STATION
    else:
        return SATELLITE


def infer_config_file(env, asset):
    asset_type = infer_asset_type(asset)
    if asset_type == GROUND_STATION:
        # Assumed to be a ground station.
        return os.path.join(env, GS_DIR, asset + ".yaml")
    elif asset_type == SATELLITE:
        # Assumed to be a satellite.
        return os.path.join(env, SAT_DIR, asset + ".yaml")
    else:
        raise ValueError(f"Unexpected asset type {asset_type}")


def str_to_yaml(val):
    yaml = YAML()
    return yaml.load(val)


def str_to_list(values):
    return values.split(",")


def str_to_bool(val):
    if val.lower() in ["y", "yes", "true", "1"]:
        return True
    if val.lower() in ["n", "no", "false", "0"]:
        return False
    raise ValueError(f"Unrecognized input '{val}'")


def channel_list(val):
    yaml = YAML()
    with open("templates.yaml", "r") as f:
        all_channels = yaml.load(f)

    if val.lower() == "all":
        return all_channels
    elif val.lower() in CONTACT_TYPE_DEFS["groups"]:
        return CONTACT_TYPE_DEFS["groups"][val.lower()]
    else:
        return str_to_list(val)


def add_editing_flags(parser):
    """Add flags for each channel definition field. Used for editing and overrides."""
    # Meta
    parser.add_argument(
        "-y",
        "--yes",
        action="store_true",
        help="Skip confirmation dialogs and make all edits.",
    )
    parser.add_argument(
        "-f",
        "--fail-fast",
        action="store_true",
        help="Do not continue with further edits after errors.",
    )
    parser.add_argument(
        "-c",
        "--comment",
        type=str,
        help="Optional comment to attach to the channel definition in the YAML file.",
    )

    # Fields
    parser.add_argument(
        "--directionality",
        type=str,
        choices=["Bidirectional", "SpaceToEarth", "EarthToSpace"],
        help="The channel direction.",
    )
    parser.add_argument(
        "--allowed_license_countries",
        type=str_to_list,
        help="The license countries which this channel can be used with as a comma separated list.",
    )
    parser.add_argument(
        "--enabled", type=str_to_bool, help="Whether the channel is enabled for use."
    )
    parser.add_argument(
        "--legal",
        type=str_to_bool,
        help="Whether the channel is licensed for legal use.",
    )
    parser.add_argument(
        "--goodput_kbps",
        type=float,
        help="Estimated upper bound on download rate for this channel.",
    )
    parser.add_argument(
        "--contact_overhead_time",
        type=str,
        help=(
            "Overhead (non-download) time to account for when using this contact type,"
            " in 'humantime' format."
        ),
    )
    parser.add_argument(
        "--ground_station_constraints",
        type=str_to_yaml,
        help="A YAML block describing the ground station constraints.",
    )
    parser.add_argument(
        "--satellite_constraints",
        type=str_to_yaml,
        help="A YAML block describing the satellite constraints.",
    )


def add_env_flag(parser):
    parser.add_argument(
        "environment",
        type=str,
        choices=ENVS,
        help=("Which environment to configure."),
    )


def add_asset_flags(parser):
    add_env_flag(parser)
    # TODO Change type to str_to_list
    parser.add_argument(
        "assets",
        type=str,
        help=(
            "The satellites or ground stations to act on. "
            "Can be a comma separated list of asset IDs, 'all_gs', 'all_sat', or 'all'."
        ),
    )
    aliases = ", ".join([f"'{g}'" for g in CONTACT_TYPE_DEFS["groups"].keys()])

    parser.add_argument(
        "channels",
        type=channel_list,
        help=(
            "The channels to act on as a comma separated list. "
            f"Also supports the following aliases: {aliases} or 'all'."
        ),
    )


PARSER = argparse.ArgumentParser(
    description="A utility to help with managing channels."
)
PARSER.add_argument("--debug", action="store_true", help="Run in debugging mode.")

SUBPARSERS = PARSER.add_subparsers()

ADD_PARSER = SUBPARSERS.add_parser(
    "add", help="Add a channel configuration from a template.", aliases=["a"]
)
ADD_PARSER.set_defaults(func=add_config)
add_editing_flags(ADD_PARSER)
add_asset_flags(ADD_PARSER)

EDIT_PARSER = SUBPARSERS.add_parser(
    "edit", help="Modify an existing channel configuration.", aliases=["e"]
)
EDIT_PARSER.set_defaults(func=edit_config)
add_editing_flags(EDIT_PARSER)
add_asset_flags(EDIT_PARSER)

AUDIT_PARSER = SUBPARSERS.add_parser(
    "audit", help="Audit a satellite/ground station pair to find usable channels."
)
AUDIT_PARSER.set_defaults(func=audit_configs)

add_env_flag(AUDIT_PARSER)
AUDIT_PARSER.add_argument(
    "satellites",
    type=str_to_list,
    help=("The satellites to audit."),
)
AUDIT_PARSER.add_argument(
    "ground_stations",
    type=str_to_list,
    help=("The ground stations to audit."),
)

VALIDATE_PARSER = SUBPARSERS.add_parser(
    "validate", help="Validate all templates and extant configurations."
)
VALIDATE_PARSER.set_defaults(func=validate_all)


if __name__ == "__main__":
    args = PARSER.parse_args()
    try:
        args.func(args)
    except Exception as e:
        if args.debug:
            raise e
        print(f"Error: {e}")
        sys.exit(1)
