#! /usr/bin/env python3

import argparse
from copy import deepcopy
import difflib
import jsonschema
from ruamel.yaml import YAML
import os
import sys
from io import StringIO

ENVS = ["staging", "production"]
SCHEMA_FILE = "schema.yaml"
SAT_DIR = "sat"
GS_DIR = "gs"
GROUND_STATION = "ground_station"
SATELLITE = "satellite"


class AlreadyExistsError(Exception):
    pass


class NoConfigurationError(Exception):
    pass


class ValidationError(Exception):
    pass


class MissingTemplateError(Exception):
    pass


def modify(cdef, args):
    """Apply modifications to a channel from argparse arguments."""
    new_cdef = deepcopy(cdef)
    vargs = vars(args)
    for field in new_cdef:
        if field in vargs and vargs[field] is not None:
            new_cdef[field] = vargs[field]
    if args.comment:
        new_cdef.yaml_set_start_comment(args.comment)
    return new_cdef


def add_config(args):
    def do_add(asset, channel, existing):
        if not existing:
            template = find_template(channel)
            return modify(template, args)
        else:
            msg = (
                f"Configuration for {channel} already exists on {asset}.\n"
                f"(Tip: Use `channel_tool edit {asset} {channel}` to edit the configuration.)"
            )
            if args.keep_going:
                print(msg)
                return existing
            else:
                raise AlreadyExistsError(msg)

    apply_update(args.environment, args.assets, args.channels, do_add, yes=args.yes)


def edit_config(args):
    def do_edit(asset, channel, existing):
        if existing:
            return modify(existing, args)
        else:
            msg = (
                f"No configuration for {channel} on {asset}.\n"
                f"(Tip: Use `channel_tool add {asset} {channel}` to add one from a template.)"
            )
            if args.keep_going:
                print(msg)
            else:
                raise NoConfigurationError(msg)

    apply_update(args.environment, args.assets, args.channels, do_edit, yes=args.yes)


def validate_all(args):
    for asset_type in [GROUND_STATION, SATELLITE]:
        print(f"Validating {asset_type} templates...")
        validate_file(
            "templates.yaml",
            inspect_keys=True,
            preprocess=lambda x: filter_properties(asset_type, x),
        )
        print("PASS")

    for env in ENVS:
        print(f"Validating {env} satellites...")
        sat_dir = os.path.join(env, SAT_DIR)
        all_sats = os.listdir(sat_dir)
        for sf in all_sats:
            print(f"{sf}... ", end="")
            validate_file(os.path.join(sat_dir, sf))
            print("PASS")

        print(f"Validating {env} ground stations...")
        gs_dir = os.path.join(env, GS_DIR)
        all_stations = os.listdir(gs_dir)
        for gsf in all_stations:
            print(f"{gsf}... ", end="")
            validate_file(os.path.join(gs_dir, gsf))
            print("PASS")

    print("All passed!")


def validate_file(cf, inspect_keys=True, preprocess=None):
    with open(cf) as f:
        yaml = YAML()
        config = yaml.load(f)
        if inspect_keys:
            for key in config:
                try:
                    c = config[key]
                    if preprocess:
                        c = preprocess(c)
                    validate_one(c)
                except Exception as e:
                    raise ValidationError(f"Failed to validate {cf}#{key}: {e}")
        else:
            try:
                c = config
                if preprocess:
                    c = preprocess(c)
                validate_one(config)
            except Exception as e:
                raise ValidationError(f"Failed to validate {cf}: {e}")


def validate_one(config):
    schema = load_schema()
    jsonschema.validate(config, schema)


# Memoize the JSON Schema definition.
loaded_schema = None


def load_schema():
    global loaded_schema
    if not loaded_schema:
        yaml = YAML()
        with open(SCHEMA_FILE) as f:
            # File has "schema" and "definitions" as top-level fields.
            loaded_schema = yaml.load(f)["schema"]
    return loaded_schema


def find_template(channel):
    template_file = "templates.yaml"
    if os.path.exists(template_file):
        with open(template_file) as f:
            yaml = YAML()
            templates = yaml.load(f)
            if channel in templates:
                return templates[channel]
            else:
                raise MissingTemplateError(f"Could not find template for {channel}")
    else:
        raise FileNotFoundError(f"Could not find file {template_file}")


def locate_assets(env, assets):
    def name(p):
        return os.path.splitext(os.path.basename(p))[0]

    if assets == "all_gs":
        return [name(p) for p in os.listdir(os.path.join(env, GS_DIR))]
    elif assets == "all_sat":
        return [name(p) for p in os.listdir(os.path.join(env, SAT_DIR))]
    elif assets == "all":
        vs = locate_assets(env, "all_gs")
        vs.extend(locate_assets(env, "all_sat"))
        return vs
    else:
        return assets.split(",")


def filter_properties(asset_type, chan):
    """Filter the channel configuration properties based on the asset type."""
    if chan:
        if asset_type != GROUND_STATION and "ground_station_constraints" in chan:
            del chan["ground_station_constraints"]
        if asset_type != SATELLITE and "satellite_constraints" in chan:
            del chan["satellite_constraints"]
    return chan


def apply_update(env, assets, channels, tfm, yes=False):
    for asset in locate_assets(env, assets):
        asset_config = load_asset_config(env, asset)
        for channel in channels:
            existing_chan = asset_config.get(channel)
            try:
                updated_chan = tfm(asset, channel, existing_chan)
                if updated_chan:
                    asset_type = infer_asset_type(asset)
                    updated_chan = filter_properties(asset_type, updated_chan)
                    validate_one(updated_chan)
                if updated_chan != existing_chan:
                    if yes or confirm_changes(
                        asset, channel, existing_chan, updated_chan
                    ):
                        asset_config[channel] = updated_chan
                        print(f"Updated {channel} definition for {asset}.")
                else:
                    print(f"No changes for {channel} on {asset}.")
            except AlreadyExistsError as e:
                print(f"Error: {e}")
        write_asset_config(env, asset, asset_config)


def confirm_changes(asset, channel, existing, new):
    print(f"Changing asset configuration for {channel} on {asset}. Diff:")
    print(
        "".join(
            difflib.unified_diff(
                dumps(existing).splitlines(keepends=True),
                dumps(new).splitlines(keepends=True),
            )
        )
    )
    response = input("Update asset configuration? [y/N] ")
    if response in ["y", "Y"]:
        return True
    else:
        print("Canceled.")
        return False


def dumps(obj):
    with StringIO() as stream:
        yaml = YAML()
        yaml.dump(obj, stream)
        return stream.getvalue()


def load_asset_config(env, asset):
    config_file = infer_config_file(env, asset)
    if not os.path.exists(config_file):
        return {}
    with open(config_file, mode="r") as f:
        yaml = YAML()
        config = yaml.load(f)
        if config:
            return config
        else:
            return {}


def write_asset_config(env, asset, asset_config):
    config_file = infer_config_file(env, asset)
    with open(config_file, mode="w+") as f:
        yaml = YAML()
        yaml.dump(asset_config, f)


def infer_asset_type(asset):
    if asset.endswith("gs"):
        return GROUND_STATION
    else:
        return SATELLITE


def infer_config_file(env, asset):
    asset_type = infer_asset_type(asset)
    if asset_type == GROUND_STATION:
        # Assumed to be a ground station.
        return os.path.join(env, GS_DIR, asset + ".yaml")
    elif asset_type == SATELLITE:
        # Assumed to be a satellite.
        return os.path.join(env, SAT_DIR, asset + ".yaml")
    else:
        raise ValueError(f"Unexpected asset type {asset_type}")


def str_to_yaml(val):
    yaml = YAML()
    return yaml.load(val)


def str_to_list(values):
    return values.split(",")


def str_to_bool(val):
    if val.lower() in ["y", "yes", "true", "1"]:
        return True
    if val.lower() in ["n", "no", "false", "0"]:
        return False
    raise ValueError(f"Unrecognized input '{val}'")


def channel_list(val):
    yaml = YAML()
    with open("templates.yaml", "r") as f:
        all_channels = yaml.load(f)

    # TODO Clean up the aliases so they use a common source of truth for definitions like "s-band"
    if val.lower() == "all":
        return all_channels
    elif val.lower() == "sband":
        return [
            c
            for c, d in all_channels.items()
            if "SBAND" in c
            or "RXO" in c
            or c == "CONTACT_BIDIR"
            or c == "CONTACT_BIDIR_DVBS2X"
        ]
    elif val.lower() == "uhf":
        return [c for c, d in all_channels.items() if "SBAND" not in c and "RXO" not in c]
    elif val.lower() == "bidir":
        return [
            c for c, d in all_channels.items() if d["directionality"] == "Bidirectional"
        ]
    elif val.lower() == "rxo":
        return [
            c for c, d in all_channels.items() if d["directionality"] == "SpaceToEarth"
        ]
    else:
        return str_to_list(val)


def add_editing_flags(parser):
    """Add flags for each channel definition field. Used for editing and overrides."""
    # Meta
    parser.add_argument(
        "--yes",
        action="store_true",
        help="Skip confirmation dialogs and make all edits.",
    )
    parser.add_argument(
        "--keep-going",
        action="store_true",
        help="Continue with further edits after errors.",
    )
    parser.add_argument(
        "--comment",
        type=str,
        help="Optional comment to attach to the channel definition in the YAML file.",
    )

    # Fields
    parser.add_argument(
        "--directionality",
        type=str,
        choices=["Bidirectional", "SpaceToEarth", "EarthToSpace"],
        help="The channel direction.",
    )
    parser.add_argument(
        "--allowed_license_countries",
        type=str_to_list,
        help="The license countries which this channel can be used with as a comma separated list.",
    )
    parser.add_argument(
        "--enabled", type=str_to_bool, help="Whether the channel is enabled for use."
    )
    parser.add_argument(
        "--legal",
        type=str_to_bool,
        help="Whether the channel is licensed for legal use.",
    )
    parser.add_argument(
        "--ground_station_constraints",
        type=str_to_yaml,
        help="A YAML block describing the ground station constraints.",
    )
    parser.add_argument(
        "--satellite_constraints",
        type=str_to_yaml,
        help="A YAML block describing the satellite constraints.",
    )
# TODO Add support for ground station/satellite constraints.


def add_asset_flags(parser):
    parser.add_argument(
        "environment",
        type=str,
        choices=ENVS,
        help=("Which environment to configure."),
    )
    parser.add_argument(
        "assets",
        type=str,
        help=(
            "The satellites or ground stations to act on. "
            "Can be a comma separated list of asset IDs, 'all_gs', 'all_sat', or 'all'."
        ),
    )
    parser.add_argument(
        "channels",
        type=channel_list,
        help=("The channels to act on as a comma separated list. "
              "Also supports the following aliases: uhf, sband, rxo, bidir."),
    )


PARSER = argparse.ArgumentParser(
    description="A utility to help with managing channels."
)
PARSER.add_argument("--debug", action="store_true", help="Run in debugging mode.")

SUBPARSERS = PARSER.add_subparsers()

ADD_PARSER = SUBPARSERS.add_parser(
    "add", help="Add a channel configuration from a template."
)
ADD_PARSER.set_defaults(func=add_config)
add_editing_flags(ADD_PARSER)
add_asset_flags(ADD_PARSER)

EDIT_PARSER = SUBPARSERS.add_parser(
    "edit", help="Modify an existing channel configuration."
)
EDIT_PARSER.set_defaults(func=edit_config)
add_editing_flags(EDIT_PARSER)
add_asset_flags(EDIT_PARSER)

VALIDATE_PARSER = SUBPARSERS.add_parser(
    "validate", help="Validate all templates and extant configurations."
)
VALIDATE_PARSER.set_defaults(func=validate_all)


if __name__ == "__main__":
    args = PARSER.parse_args()
    try:
        args.func(args)
    except Exception as e:
        if args.debug:
            raise e
        print(f"Error: {e}")
        sys.exit(1)
